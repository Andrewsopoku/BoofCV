package gecv.alg.filter.convolve.impl;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;

/**
 * @author Peter Abeles
 */
public class GenerateConvolvedUnrolled {

	final static int numUnrolled = 5;

	PrintStream out;
	String className;
	String typeKernel;
	String typeInput;
	String typeOutput;
	String dataKernel;
	String dataInput;
	String dataOutput;
	String bitWise;
	String sumType;

	public void createAll() throws FileNotFoundException {
		createF32();
		createI8_I16();
		createI16_I16();
	}

	public void createF32() throws FileNotFoundException {
		className = "ConvolveImageUnrolled_F32_F32";
		typeKernel = "Kernel1D_F32";
		typeInput = "ImageFloat32";
		typeOutput = "ImageFloat32";
		dataKernel = "float";
		dataInput = "float";
		dataOutput = "float";
		sumType = "float";
		bitWise = "";

		createFile();
	}

	public void createI8_I16() throws FileNotFoundException {
		className = "ConvolveImageUnrolled_I8_I16";
		typeKernel = "Kernel1D_I32";
		typeInput = "ImageInt8";
		typeOutput = "ImageInt16";
		dataKernel = "int";
		dataInput = "byte";
		dataOutput = "short";
		sumType = "int";
		bitWise = " & 0xFF";

		createFile();
	}

	public void createI16_I16() throws FileNotFoundException {
		className = "ConvolveImageUnrolled_I16_I16";
		typeKernel = "Kernel1D_I32";
		typeInput = "ImageInt16";
		typeOutput = "ImageInt16";
		dataKernel = "int";
		dataInput = "short";
		dataOutput = "short";
		sumType = "int";
		bitWise = "";

		createFile();
	}

	public void createFile() throws FileNotFoundException {
		out = new PrintStream(new FileOutputStream(className + ".java"));

		printPreamble();
		createMaster("horizontal");
		createMaster("vertical");
		for (int i = 0; i < numUnrolled; i++) {
			addHorizontal(3 + i * 2);
		}
		for (int i = 0; i < numUnrolled; i++) {
			addVertical(3 + i * 2);
		}
		out.println("}");
	}

	public void printPreamble() {
		out.print("package gecv.alg.filter.convolve.impl;\n");
		out.println();
		out.print("import gecv.struct.convolve." + typeKernel + ";\n");
		out.print("import gecv.struct.image." + typeInput + ";\n");
		if (typeInput.compareTo(typeOutput) != 0)
			out.print("import gecv.struct.image." + typeOutput + ";\n");
		out.print("\n" +
				"/**\n" +
				" * <p>\n" +
				" * Unrolls the convolution kernel to reduce array accessing and save often used variables to the stack.\n" +
				" * </p>\n" +
				" *\n" +
				" * <p>\n" +
				" * Unrolling the image being convolved resulting in an additional 10% performance boost on a Core i7 processor,\n" +
				" * see commented out code below.  Due to the added complexity it was decided that this performance boost was\n" +
				" * not worth it.  By comparison, unrolling the kernel causes a performance boost between 2 and 3 times.\n" +
				" * </p>\n" +
				" * \n" +
				" * <p>\n" +
				" * DO NOT MODIFY.  This class was automatically generated by {@link GenerateConvolvedUnrolled}.\n" +
				" * </p>\n" +
				" *\n" +
				" * @author Peter Abeles\n" +
				" */\n" +
				"public class " + className + " {\n");
	}

	public void createMaster(String opName) {
		out.print("\tpublic static boolean " + opName + "( " + typeKernel + " kernel ,\n" +
				"\t\t\t\t\t\t\t\t   " + typeInput + " image, " + typeOutput + " dest,\n" +
				"\t\t\t\t\t\t\t\t   boolean includeBorder) {\n" +
				"\t\tswitch( kernel.width ) {\n");
		for (int i = 0; i < numUnrolled; i++) {
			int num = 3 + i * 2;
			out.print("\t\t\tcase " + num + ":\n");
			out.print("\t\t\t\t" + opName + num + "(kernel,image,dest,includeBorder);\n" +
					"\t\t\t\tbreak;\n" +
					"\n");
		}
		out.print("\t\t\tdefault:\n" +
				"\t\t\t\treturn false;\n" +
				"\t\t}\n" +
				"\t\treturn true;\n" +
				"\t}\n\n");
	}

	public void addHorizontal(int num) {
		String typeCast = generateTypeCast();

		out.print("\tpublic static void horizontal" + num + "( " + typeKernel + " kernel ,\n" +
				"\t\t\t\t\t\t\t\t\t" + typeInput + " image, " + typeOutput + " dest,\n" +
				"\t\t\t\t\t\t\t\t\tboolean includeBorder) {\n" +
				"\t\tfinal " + dataInput + "[] dataSrc = image.data;\n" +
				"\t\tfinal " + dataOutput + "[] dataDst = dest.data;\n" +
				"\n");
		for (int i = 0; i < num; i++) {
			out.printf("\t\tfinal " + dataKernel + " k%d = kernel.data[%d];\n", (i + 1), i);
		}
		out.print("\n" +
				"\t\tfinal int radius = kernel.getRadius();\n" +
				"\n" +
				"\t\tfinal int yBorder = includeBorder ? 0 : radius;\n" +
				"\n" +
				"\t\tfinal int width = image.getWidth();\n" +
				"\t\tfinal int height = image.getHeight()-yBorder;\n" +
				"\n" +
				"\t\tfor( int i = yBorder; i < height; i++ ) {\n" +
				"\t\t\tint indexDst = dest.startIndex + i*dest.stride+radius;\n" +
				"\t\t\tint j = image.startIndex+ i*image.stride;\n" +
				"\t\t\tfinal int jEnd = j+width-radius;\n" +
				"\n" +
				"\t\t\tfor( j += radius; j < jEnd; j++ ) {\n" +
				"\t\t\t\tint indexSrc = j-radius;\n" +
				"\t\t\t\t" + sumType + " total = (dataSrc[indexSrc++]" + bitWise + ")*k1;\n");
		for (int i = 1; i < num - 1; i++) {
			out.printf("\t\t\t\ttotal += (dataSrc[indexSrc++]" + bitWise + ")*k%d;\n", (i + 1));
		}
		out.printf("\t\t\t\ttotal += (dataSrc[indexSrc]" + bitWise + ")*k%d;\n", num);
		out.printf("\n" +
				"\t\t\t\tdataDst[indexDst++] = " + typeCast + "total;\n" +
				"\t\t\t}\n" +
				"\t\t}\n" +
				"\t}\n\n");
	}

	public void addVertical(int num) {
		String typeCast = generateTypeCast();

		out.print("\tpublic static void vertical" + num + "( " + typeKernel + " kernel,\n" +
				"\t\t\t\t\t\t\t\t " + typeInput + " image, " + typeOutput + " dest,\n" +
				"\t\t\t\t\t\t\t\t boolean includeBorder)\n" +
				"\t{\n" +
				"\t\tfinal " + dataInput + "[] dataSrc = image.data;\n" +
				"\t\tfinal " + dataOutput + "[] dataDst = dest.data;\n" +
				"\n");
		for (int i = 0; i < num; i++) {
			out.printf("\t\tfinal " + dataKernel + " k%d = kernel.data[%d];\n", (i + 1), i);
		}
		out.print("\n" +
				"\t\tfinal int radius = kernel.getRadius();\n" +
				"\n" +
				"\t\tfinal int imgWidth = dest.getWidth();\n" +
				"\t\tfinal int imgHeight = dest.getHeight();\n" +
				"\n" +
				"\t\tfinal int yEnd = imgHeight-radius;\n" +
				"\n" +
				"\t\tfinal int xBorder = includeBorder ? 0 : radius;\n" +
				"\n" +
				"\t\tfor( int y = radius; y < yEnd; y++ ) {\n" +
				"\t\t\tint indexDst = dest.startIndex+y*dest.stride+xBorder;\n" +
				"\t\t\tint i = image.startIndex+y*image.stride;\n" +
				"\t\t\tfinal int iEnd = i+imgWidth-xBorder;\n" +
				"\n" +
				"\t\t\tfor( i += xBorder; i < iEnd; i++ ) {\n" +
				"\t\t\t\tint indexSrc = i-radius*image.stride;\n" +
				"\n" +
				"\t\t\t\t" + sumType + " total = dataSrc[indexSrc] * k1;\n");
		for (int i = 1; i < num; i++) {
			out.printf("\t\t\t\tindexSrc += image.stride;\n");
			out.printf("\t\t\t\ttotal += (dataSrc[indexSrc]" + bitWise + ")*k%d;\n", (i + 1));
		}
		out.print("\n" +
				"\t\t\t\tdataDst[indexDst++] = " + typeCast + "total;\n" +
				"\t\t\t}\n" +
				"\t\t}\n" +
				"\t}\n\n");
	}

	private String generateTypeCast() {
		return sumType.compareTo(dataOutput) == 0 ? "" : "( " + dataOutput + " )";
	}

	public static void main(String args[]) throws FileNotFoundException {
		GenerateConvolvedUnrolled a = new GenerateConvolvedUnrolled();

		a.createAll();
	}
}
