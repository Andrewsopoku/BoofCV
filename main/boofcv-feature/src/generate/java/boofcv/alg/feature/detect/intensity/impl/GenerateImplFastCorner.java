/*
 * Copyright (c) 2011-2018, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.alg.feature.detect.intensity.impl;

import boofcv.misc.AutoTypeImage;
import boofcv.misc.CircularIndex;
import boofcv.misc.CodeGeneratorBase;

import java.io.FileNotFoundException;

/**
 * @author Peter Abeles
 */
public class GenerateImplFastCorner extends CodeGeneratorBase {

	private static final int TOTAL_CIRCLE = 16;

	// minimum number of edge points in a row to make a corner
	private int minContinuous;

	AutoTypeImage imageType;
	String sumType;
	String bitwise;
	String dataType;

	public GenerateImplFastCorner() {
		super(false);
	}

	@Override
	public void generate() throws FileNotFoundException {
//		int n[] = {9,10,11,12};
//		AutoTypeImage d[] = {AutoTypeImage.U8,AutoTypeImage.F32};

		int n[] = {9};
		AutoTypeImage d[] = {AutoTypeImage.U8};

		for( int minContinuous : n ) {
			for( AutoTypeImage imageType : d ) {
				createFile(imageType,minContinuous);
			}
		}
	}

	public void createFile( AutoTypeImage imageType , int minContinuous ) throws FileNotFoundException {
		className = "ImplFastCorner"+minContinuous+"_"+imageType.getAbbreviatedType();

		this.imageType = imageType;
		this.sumType = imageType.getSumType();
		this.bitwise = imageType.getBitWise();
		this.dataType = imageType.getDataType();
		this.minContinuous = minContinuous;

		initFile();
		printPreamble();
		printCheck();

		out.println("}");
	}


	private void printPreamble() throws FileNotFoundException {
		out.print(
				"/**\n" +
				" * <p>\n" +
				" * Contains logic for detecting fast corners. Pixels are sampled such that they can eliminate the most\n" +
				" * number of possible corners, reducing the number of samples required.\n" +
				" * </p>\n" +
				" *\n" +
				" * <p>\n" +
				" * DO NOT MODIFY. Generated by "+getClass().getSimpleName()+".\n" +
				" * </p>\n" +
				" *\n" +
				" * @author Peter Abeles\n" +
				" */\n" +
				"public class "+className+"n" +
				"{\n" +
				"\n" +
				"\tint offsets[]=new int[16]\n" +
				"\t"+sumType+" minValue;\n"+
				"\t"+sumType+" maxValue;\n"+
				"\t"+sumType+" tol;\n"+
				"\t"+sumType+" lower;\n"+
				"\t"+sumType+" upper;\n\n");
	}

	private void printCheck() {

		out.print(
				"\t/**\n" +
				"\t * @return 1 = positive corner, 0 = no corner, -1 = negative corner\n" +
				"\t */\n" +
				"\t@Override\n" +
				"\tprotected int checkCorner( "+dataType+" data[], int index )\n" +
				"\t{\n" +
				"\t"+sumType+" lower = Math.max(minValue,(data[index]"+bitwise+") - tol)\n"+
				"\t"+sumType+" upper = Math.min(maxValue,(data[index]"+bitwise+") + tol)\n"+
				"\n");

		print();

		out.print("\t}\n\n");
	}

	private void print() {
		StateAction state = StateAction.FORWARDS;
		int tabs = 1;
		int start = 0;
		int end = 0;
		boolean undo = false;
		boolean alternativePath = false;
		boolean checkUpper = true;
		int swaps[] = new int[ TOTAL_CIRCLE ];
		int root[] = new int[ TOTAL_CIRCLE ];

		while( true ) {
			System.out.println("tabs "+tabs+" start/end = "+start+"/"+end+" upper="+checkUpper+" undo="+undo+" state="+state+" root[end]="+root[end]);
			if( undo ) {
				if( start == end ) {
					end -= 1;
					printCloseIf(tabs);

					if( swaps[end] == 0 ) {
						swaps[end] = 1;
						tabs -= 1;
						end -= 1;
						start = end;
						swaps[end] = 1;
						checkUpper = !checkUpper;
						state = StateAction.FORWARDS;
						undo = false;
						alternativePath = true;
					} else {
						tabs -= 1;
						end -= 1;
					}
				} else {
					switch (state) {
						case FORWARDS: {

							end -= 1;
							if (possibleToComplete(end) && swaps[end] < 1) {
								start = end;
								checkUpper = !checkUpper;
								undo = false;
								alternativePath = true;
								swaps[end] = 1;
							} else {
								printCloseIf(tabs);
								tabs -= 1;
							}
						} break;

						case BACKWARDS: {
							// Could potentially run a bit faster it it considered
							// lower in reverse direction instead of undoing. but would make things
							// more complex
							start = CircularIndex.addOffset(start,1,TOTAL_CIRCLE);
							printCloseIf(tabs);
							tabs -= 1;
							if( start == 0 ) {
								if (possibleToComplete(end) && swaps[end] < 1) {
									state = StateAction.FORWARDS;
									swaps[end] = 1;
									root[end] = end;
									start = end;
									checkUpper = !checkUpper;
									alternativePath = true;
								} else {
									alternativePath = true;
									start = TOTAL_CIRCLE-1;
								}
								end -= 1;
								undo = false;
							}
						} break;
					}
				}
			} else {
				switch (state) {
					case FORWARDS: {
						root[end] = start;
						printIf(alternativePath, tabs, end, checkUpper);
						if (length(start, end) == minContinuous) {
							// print logic for it completing the minimum number of continuous hits
							printReturn(tabs, checkUpper?1:-1);
							// now consider the situation where it failed the check
							if (start == 0 && swaps[end] == 0 ) {
								// see if it should consider the reverse direction
								swaps[end] = -1;
								start = 15;
								state = StateAction.BACKWARDS;
								alternativePath = true;
							} else if (possibleToComplete(end) && swaps[end] < 1 ) {
								// if it switched to checking the other direction could that finish?
								swaps[end] = 1;
								checkUpper = !checkUpper;
								alternativePath = true;
							} else {
								// nope, can't consider any other possibilities
								printCloseIf(tabs);
								undo = true;
								tabs -= 1;
							}
						} else {
							alternativePath = false;
							end += 1;
							tabs += 1;
							swaps[end] = 0;
						}
					}break;

					case BACKWARDS: {
						printIf(alternativePath, tabs, start, checkUpper);
						alternativePath = false;
						if( length(start,end) > minContinuous ) {
							printReturn(tabs, checkUpper?1:-1);
							undo = true;
						} else {
							start -= 1;
							tabs += 1;
						}
					} break;
				}
			}
			try {
				Thread.sleep(125);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

	}

	private static int length( int start , int end ) {
		return CircularIndex.distanceP(start,end,TOTAL_CIRCLE)+1;
	}

	private boolean possibleToComplete( int location ) {
		return (16-location) >= minContinuous;
	}

	private void printIf( boolean isElse, int numTabs , int bit,  boolean upper ) {
		String comparison = upper ? "> upper" : "< lower";
		String strElse = isElse ? "} else " : "";
		out.println(tabs(numTabs)+strElse+"if( "+readBit(bit)+" "+comparison+" ) {");
	}

	private void printReturn( int numTabs , int value ) {
		out.println(tabs(numTabs+1)+"return "+value+";");
	}

	private String readBit( int bit ) {
		return "(data[offsets["+bit+"]]"+bitwise+")";
	}

	private void printCloseIf( int numTabs ) {
		out.println(tabs(numTabs)+"}");
	}

	/**
	 * Prints tabs to ensure proper formatting
	 */
	private String tabs( int depth ) {
		String ret = "";
		for( int i = 0; i < depth; i++ ) {
			ret += "\t";
		}
		return ret;
	}

	enum StateAction {
		FORWARDS,
		BACKWARDS
	}

	public static void main( String args[] ) throws FileNotFoundException {
		GenerateImplFastCorner gen = new GenerateImplFastCorner();
		gen.generate();
	}

}
