/*
 * Copyright (c) 2011-2018, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.alg.feature.detect.intensity.impl;

import boofcv.misc.AutoTypeImage;
import boofcv.misc.CircularIndex;
import boofcv.misc.CodeGeneratorBase;
import org.ddogleg.struct.FastQueue;

import java.io.FileNotFoundException;

/**
 * @author Peter Abeles
 */
public class GenerateImplFastCorner extends CodeGeneratorBase {

	private static final int TOTAL_CIRCLE = 16;

	// minimum number of edge points in a row to make a corner
	private int minContinuous;

	AutoTypeImage imageType;
	String sumType;
	String bitwise;
	String dataType;

	public GenerateImplFastCorner() {
		super(false);
	}

	@Override
	public void generate() throws FileNotFoundException {
//		int n[] = {9,10,11,12};
//		AutoTypeImage d[] = {AutoTypeImage.U8,AutoTypeImage.F32};

		int n[] = {9};
		AutoTypeImage d[] = {AutoTypeImage.U8};

		for( int minContinuous : n ) {
			for( AutoTypeImage imageType : d ) {
				createFile(imageType,minContinuous);
			}
		}
	}

	public void createFile( AutoTypeImage imageType , int minContinuous ) throws FileNotFoundException {
		className = "ImplFastCorner"+minContinuous+"_"+imageType.getAbbreviatedType();

		this.imageType = imageType;
		this.sumType = imageType.getSumType();
		this.bitwise = imageType.getBitWise();
		this.dataType = imageType.getDataType();
		this.minContinuous = minContinuous;

		initFile();
		printPreamble();
		printCheck();

		out.println("}");
	}


	private void printPreamble() throws FileNotFoundException {
		out.print(
				"/**\n" +
				" * <p>\n" +
				" * Contains logic for detecting fast corners. Pixels are sampled such that they can eliminate the most\n" +
				" * number of possible corners, reducing the number of samples required.\n" +
				" * </p>\n" +
				" *\n" +
				" * <p>\n" +
				" * DO NOT MODIFY. Generated by "+getClass().getSimpleName()+".\n" +
				" * </p>\n" +
				" *\n" +
				" * @author Peter Abeles\n" +
				" */\n" +
				"public class "+className+"n" +
				"{\n" +
				"\n" +
				"\tint offsets[]=new int[16]\n" +
				"\t"+sumType+" minValue;\n"+
				"\t"+sumType+" maxValue;\n"+
				"\t"+sumType+" tol;\n"+
				"\t"+sumType+" lower;\n"+
				"\t"+sumType+" upper;\n\n");
	}

	private void printCheck() {

		out.print(
				"\t/**\n" +
				"\t * @return 1 = positive corner, 0 = no corner, -1 = negative corner\n" +
				"\t */\n" +
				"\t@Override\n" +
				"\tprotected int checkCorner( "+dataType+" data[], int index )\n" +
				"\t{\n" +
				"\t"+sumType+" lower = Math.max(minValue,(data[index]"+bitwise+") - tol)\n"+
				"\t"+sumType+" upper = Math.min(maxValue,(data[index]"+bitwise+") + tol)\n"+
				"\n");

		print();

		out.print("\t}\n\n");
	}

	private void print() {
		FastQueue<Set> queue = new FastQueue<>(Set.class,true);

		Set active = queue.grow();
		active.start = 0;
		active.complete = false;
		active.upper = true;
		active.tabsAtZero = 1;

		while( queue.size > 0 ) {
			active = queue.getTail();
			System.out.println("start "+active.start+" "+active.stop+" "+active.upper);

			int length = active.length();
			int bit = active.start > active.stop ? active.start : active.stop;
			printIf(length==0&&queue.size>1, active.tabsAtZero+length, bit, active.upper);

			boolean createNext = false;
			if( length+1 == minContinuous ) {
				active.complete = true;
				active.stop += 1;
				createNext = true;
			} else if( active.complete ){
				if( queue.size == 1 ) {
					active.stop -= 1;
					active.start = TOTAL_CIRCLE - minContinuous + active.stop + 1;
				} else {
					active.stop -= 1;
				}
				createNext = true;


			} else {
				active.stop += 1;
			}

			if( createNext ) {
				int start= active.start > active.stop ? 0 : active.start;
				while( !possibleToComplete(active.stop) && active.stop > start ) {
					active.stop -= 1;
				}
				if( active.stop > active.start ) {
					Set next = queue.grow();
					next.start = next.stop = active.stop;
					next.complete = false;
					next.upper = !active.upper;
					next.tabsAtZero = active.tabsAtZero + length;
				} else if( active.upper ) {
					active.upper = false;
					active.stop = active.start = 0;
					active.complete = false;
				} else {
					queue.removeTail();
				}
			}

			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private boolean possibleToComplete( int location ) {
		return (16-location) >= minContinuous;
	}

	private void printIf( boolean isElse, int numTabs , int bit,  boolean upper ) {
		String comparison = upper ? "> upper" : "< lower";
		String strElse = isElse ? "} else " : "";
		out.println(tabs(numTabs)+strElse+"if( "+readBit(bit)+" "+comparison+" ) {");
	}

	private void printReturn( int numTabs , int value ) {
		out.println(tabs(numTabs+1)+"return "+value+";");
	}

	private String readBit( int bit ) {
		return "(data[offsets["+bit+"]]"+bitwise+")";
	}

	private void printCloseIf( int numTabs ) {
		out.println(tabs(numTabs)+"}");
	}

	/**
	 * Prints tabs to ensure proper formatting
	 */
	private String tabs( int depth ) {
		String ret = "";
		for( int i = 0; i < depth; i++ ) {
			ret += "\t";
		}
		return ret;
	}

	enum StateAction {
		FORWARDS,
		BACKWARDS
	}

	public static class Set {
		int start,stop;
		boolean upper;
		boolean complete;
		int tabsAtZero;

		public int length() {
			return CircularIndex.distanceP(start,stop,TOTAL_CIRCLE);
		}
	}

	public static void main( String args[] ) throws FileNotFoundException {
		GenerateImplFastCorner gen = new GenerateImplFastCorner();
		gen.generate();
	}

}
